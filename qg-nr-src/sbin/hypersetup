#!/usr/bin/perl

######################################################################
#
# Tue Jan 27 13:47:38 CST 2004
#
# hypersetup
#        
#     by David Neilsen
#     input:   hyper function information from standard input
#     output:  
#
# 02.10.2004 Steve Liebling, hack to have grid specific dx/dt in assign_params
# 30.09.2004 Nina Jansen, seperating amr/hyper pars from local pars
######################################################################

use Cwd; 

######################################################################
#
#  If $debug=1 then the script generates some output to indicate status.
#  $debug2=1 gives more extensive messages.
#  To generate Fortran-style array indexing (begin with 1) set begidx=1;
#  C-style array indexing is given with begidx=0.
#
######################################################################
$debug = 1;
$debug2 = 1;
$begidx = 1;

$MAXLEVELS = 25;

$pwd = cwd(); 

######################################################################
#
#  Read from STDIN.  Comments and whitespace are removed.
#
######################################################################

@lines=();
while (<STDIN>) {
  chop;
  s/\#.*//;  # get rid of comments
  s/\s//g;   # get rid of whitespace

  if ($_ ne "") {    # Get rid of blank lines
    push(@lines,$_);
  }
}

######################################################################
#
#  Read from had/src/amr/setup.  Comments and whitespace are removed.
#
######################################################################
$amrsetupfile = "$pwd/../src/amr/setup";

open(AMR,$amrsetupfile);

while (<AMR>) {
  chop;
  s/\#.*//;  # get rid of comments
  s/\s//g;   # get rid of whitespace

  if ($_ ne "") {    # Get rid of blank lines
    push(@lines,$_);
  }
}

close(AMR);

######################################################################
#
#  Read from had/src/hyper/setup.  Comments and whitespace are removed.
#
######################################################################
$hypersetupfile = "$pwd/../src/hyper/setup";

open(HYPER,$hypersetupfile);

while (<HYPER>) {
  chop;
  s/\#.*//;  # get rid of comments
  s/\s//g;   # get rid of whitespace

  if ($_ ne "") {    # Get rid of blank lines
    push(@lines,$_);
  }
}

close(HYPER);

######################################################################
#
#  Now parse the data in @lines.  Sort the variables into arrays: 
#  u, v, w, du, dv and par.
#
######################################################################
@u   = ();
@du  = ();
@v   = ();
@dv  = ();
@w   = ();
@derivs = ();

@params  =();
@params_type = ();
@params_size = ();
@params_val  = ();
@params_vmin = ();
@params_vmax = ();

@par  =();
@par_type=();
@par_size=();
@par_val=();
@par_vmin=();
@par_vmax=();

@apar  =();
@apar_type=();
@apar_size=();
@apar_val=();
@apar_vmin=();
@apar_vmax=();



$read_u = 0;
$read_v = 0;
$read_w = 0;
$read_du = 0;
$read_dv = 0;
$read_par = 0;
$read_derivs = 0;
$xptderivs = 1;
$usemask = 0;
$hyper_rhs1 = 1;
$hyper_rhs2 = 1;
$hyper_derivs = 1;
$need_c_files = 0;

print "@lines\n";

$i = 0;
while ($i <= $#lines) {
  $_ = $lines[$i];

  if (/^ufuncs/) {
    $read_u = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        @local = split(",",$_);
        push(@u, @local);
        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading u.  Expect line with {\n";
    }
  }

  if (/^dufuncs/) {
    print "READING DUFUNCS\n";
    $read_du = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        @local = split(",",$_);
        push(@du, @local);
        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading du.  Expect line with {\n";
    }
  }


  if (/^vfuncs/) {
    $read_v = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        @local = split(",",$_);
        push(@v, @local);
        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading v.  Expect line with {\n";
    }
  }

  if (/^dvfuncs/) {
    $read_dv = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        @local = split(",",$_);
        push(@dv, @local);
        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading dv.  Expect line with {\n";
    }
  }

  if (/^wfuncs/) {
    $read_w = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        @local = split(",",$_);
        push(@w, @local);
        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading w.  Expect line with {\n";
    }
  }

  if (/^par/) {
    $read_par = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        ($nn, $tt, $ss, $vn, $vx, $vv) = split(/:/, $_, 6);
        if ($debug) {
          print "$nn, $tt, $ss, $vn, $vx, $vv\n";
        }

        push (@par, $nn);
        push (@par_type, $tt);
        push (@par_size, $ss);
        push (@par_val,  $vv);
        push (@par_vmin, $vn);
        push (@par_vmax, $vx);

        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading par.  Expect line with {\n";
    }
  }


  if (/^amr_par/) {

    $read_par = 1;
    $_ = $lines[++$i];
    if (m:^\{:) {
      $_ = $lines[++$i];
      while (!(m:^\}:)) {
        ($nn, $tt, $ss, $vn, $vx, $vv) = split(/:/, $_, 6);
        if ($debug) {
          print "$nn, $tt, $ss, $vn, $vx, $vv\n";
        }

        push (@apar, $nn);
        push (@apar_type, $tt);
        push (@apar_size, $ss);
        push (@apar_val,  $vv);
        push (@apar_vmin, $vn);
        push (@apar_vmax, $vx);

        $_ = $lines[++$i];
      }
    }
    else {
      die "parse error reading amr_par.  Expect line with {\n";
    }
  }

  if (/^Point-wiseDerivatives/) {
    $xptderivs = 0;
    print STDERR "Point-wise Derivatives\n" if ($debug);
  }

  if (/^EnableAlternativeCoordinates/) {
    $usealtcoords = 1;
    print STDERR "Enable Alternative Coordinates\n" if ($debug);
  }

  if (/^NoHyperRHS1/) {
    $hyper_rhs1 = 0;
    print STDERR "No HyperRHS1\n" if ($debug);
  }

  if (/^NoHyperRHS2/) {
    $hyper_rhs2 = 0;
    print STDERR "No HyperRHS2\n" if ($debug);
  }

  if (/^NoHyperDerivs/) {
    $hyper_derivs = 0;
    print STDERR "No HyperDerivs\n" if ($debug);
  }

  if (/^NeedCFiles/) {
    $need_c_files = 1;
    print STDERR "Creating C files\n" if ($debug);
  }


  $i++;
}

#
# (sll 11/05): My src/amr routines need the mask now, so
#  force the creation of the mask array for all projects.
#
# if (/^UseMask/) {
    $usemask = 1;
    print STDERR "Use Mask\n" if ($debug);
# }


if ($debug) {
 #print STDERR "lines:@lines\n";
  print STDERR "After parsing the input\n";
  print STDERR "usemask   $usemask\n";
  print STDERR "xptderivs $xptderivs\n";
  print STDERR "u:    @u\n";
  print STDERR "du:   @du\n";
  print STDERR "v:    @v\n";
  print STDERR "dv:   @dv\n";
  print STDERR "w:    @w\n";
  print STDERR "par ($#params):  @par\n";
  print STDERR "apar ($#params):  @apar\n";
}

######################################################################
######################################################################
######################################################################
#
# Now process the information from STDIN.  
#
######################################################################
######################################################################
######################################################################


######################################################################
#
#  Check to see if excision values have been included in the u array.
#  Load this info into u_exc_val, and then strip it from the names in @u.
#  The default excise_val is zero.
#
######################################################################
@u_exc_val = ();
for($i=0; $i<=$#u; $i++) {
  $e = $u[$i];
  if ($e =~ /\[(.*?)\]/ ) {
    print STDERR "exc$e has $1\n";
    push(@u_exc_val, $1);
  }
  else {
    push(@u_exc_val, 0.0);
  }
  $e =~ s/\[.*?\]//;
  $u[$i] = $e;
}

@u_farlimit_val = ();
for($i=0; $i<=$#u; $i++) {
  $e = $u[$i];
  if ($e =~ /\[(.*?)\]/ ) {
    print STDERR "farlimit $e has $1\n";
    push(@u_farlimit_val, $1);
  }
  else {
    push(@u_farlimit_val, 0.0);
  }
  $e =~ s/\[.*?\]//;
  $u[$i] = $e;
}

@u_falloff_val = ();
for($i=0; $i<=$#u; $i++) {
  $e = $u[$i];
  if ($e =~ /\[(.*?)\]/ ) {
    print STDERR "falloff $e has $1\n";
    push(@u_falloff_val, $1);
  }
  else {
    push(@u_falloff_val, 0.0);
  }
  $e =~ s/\[.*?\]//;
  $u[$i] = $e;
}

@u_pspeed_val = ();
for($i=0; $i<=$#u; $i++) {
  $e = $u[$i];
  if ($e =~ /\[(.*?)\]/ ) {
    print STDERR "pspeed $e has $1\n";
    push(@u_pspeed_val, $1);
  }
  else {
    push(@u_pspeed_val, 0.0);
  }
  $e =~ s/\[.*?\]//;
  $u[$i] = $e;
}


######################################################################
#
# Generate names for du and dv if they are not explicitly given in the file.
#
######################################################################

# Generate all possible derivative names, and store in du_all, dv_all
foreach $e (@u) {
  $dxf = "dx_" . "$e";
  $dyf = "dy_" . "$e";
  $dzf = "dz_" . "$e";
  push(@du_all,$dxf,$dyf,$dzf);
}
foreach $e (@v) {
  $dxf = "dx_" . "$e";
  $dyf = "dy_" . "$e";
  $dzf = "dz_" . "$e";
  push(@dv_all,$dxf,$dyf,$dzf);
}

# If du_derivs and/or dv_derivs not defined in file, set them to d(u||v)_all
if (!($read_du)) {
  @du = @du_all;
}
if (!($read_dv)) {
  @dv = @dv_all;
}



@derivprefix = ("dx_","dy_","dz_");

@n_dxu = ();
@n_dyu = ();
@n_dzu = ();
for($i=0; $i<=$#u; $i++) {
  $n_dxu[$i]=0;
  $n_dyu[$i]=0;
  $n_dzu[$i]=0;
}
for($i=0; $i<=$#u; $i++) {
  $ee = $u[$i];
  foreach $prefix (@derivprefix) {
    $e = $prefix . $ee;
    $found = 0;
    foreach $e2 (@du) {
      if ($e eq $e2) {
        $found = 1;
      }
    }
    if ($found) {
      if ($prefix eq "dx_") {
        $n_dxu[$i] = 1;
      }
      elsif ($prefix eq "dy_") {
        $n_dyu[$i] = 1;
      }
      elsif ($prefix eq "dz_") {
        $n_dzu[$i] = 1;
      }
    }
  }
}

@n_dxv = ();
@n_dyv = ();
@n_dzv = ();
for($i=0; $i<=$#v; $i++) {
  $n_dxv[$i]=0;
  $n_dyv[$i]=0;
  $n_dzv[$i]=0;
}
for($i=0; $i<=$#v; $i++) {
  $ee = $v[$i];
  foreach $prefix (@derivprefix) {
    $e = $prefix . $ee;
    $found = 0;
    foreach $e2 (@dv) {
      if ($e eq $e2) {
        $found = 1;
      }
    }
    if ($found) {
      if ($prefix eq "dx_") {
        $n_dxv[$i] = 1;
      }
      elsif ($prefix eq "dy_") {
        $n_dyv[$i] = 1;
      }
      elsif ($prefix eq "dz_") {
        $n_dzv[$i] = 1;
      }
    }
  }
}

if ($debug2) {
  print STDERR "ndu = @ndu\n";
  print STDERR "ndv = @ndv\n";
}

######################################################################
######################################################################
#
# Hyper vars.  These are hyper variables and functions are always 
# needed.  They don't need to be included in the hyperfcn file.
#
######################################################################
######################################################################
@hyperw = ( "cctk_x", "cctk_y", "cctk_z", "r", "xphys", "yphys", "zphys");

if ($usemask) {
  push(@hyperw,"mask");
}

@params = (@par, @apar);
@params_type = (@par_type, @apar_type);
@params_size = (@par_size, @apar_size);
@params_val = (@par_val, @apar_val);
@params_vmin = (@par_vmin, @apar_vmin);
@params_vmax = (@par_vmax, @apar_vmax);


unshift(@w,@hyperw);

if ($debug2) {
  print STDERR "After adding the hyper functions\n";
  print STDERR "u:    @u\n";
  print STDERR "du:   @du\n";
  print STDERR "v:    @v\n";
  print STDERR "dv:   @dv\n";
  print STDERR "w:    @w\n";
  print STDERR "par:  @params\n";
}


######################################################################
#
#  Prepare to write the Fortran paramter file
#
######################################################################
$paramfile = "params.x";
$ndim = 3;
$nbholes = 2;
$nu = $#u + 1;
$nv = $#v + 1;
$nw = $#w + 1;
$ndu = $#du + 1;
$ndv = $#dv + 1;
$npar = $#params  + 1;

#
# Make sure that all arrays have at least one element to prevent problems
# with Fortran compilers when attempting to define zero size arrays.
#
$nu = 1 if ($nu < 1);
$nvsize = $nv;
if ($nv < 1) {
  $nv = 1;
  $nvsize = 0;
}
$nw = 1 if ($nw < 1);
$npar = 1 if ($npar < 1);

open(PARFILE,">$paramfile");
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! This is a machine-generated file.  Do not edit this file\n";
print PARFILE "! directly.  Rather edit the hypersetup script.\n!\n";
print PARFILE "! This module defines function names and code parameters \n";
print PARFILE "! as Fortran parameters.\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "      MODULE PARAMS\n";

print PARFILE "      integer, parameter:: NDIM = $ndim\n";
print PARFILE "      integer, parameter:: NU = $nu\n";
print PARFILE "      integer, parameter:: NV = $nv\n";
print PARFILE "      integer, parameter:: NW = $nw\n";
print PARFILE "      integer, parameter:: NPAR = $npar\n";

print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! The u functions\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
$i = $begidx;
foreach $e (@u) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print PARFILE "      integer, parameter:: H_$e1 = $i\n";
  $i++;
}

print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! The v functions\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
$i = $begidx;
foreach $e (@v) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print PARFILE "      integer, parameter:: H_$e1 = $i\n";
  $i++;
}

print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! The w functions\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
$i = $begidx;
foreach $e (@w) {
  $e1 = $e;
  $e1 =~ s/cctk_//g;
  $e1 =~ tr/a-z/A-Z/;
  print PARFILE "      integer, parameter:: H_$e1 = $i\n";
  $i++;
}

print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! The parameters\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
$i = $begidx;
foreach $e (@params) {
  $e1 = $e;
  $e1 =~ s/local_//;
  $e1 =~ tr/a-z/A-Z/;
  print PARFILE "      integer, parameter:: P_$e1 = $i\n";
  $i++;
}

print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "! Additional hyper variables for the mask and derivatives.\n";
print PARFILE "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
print PARFILE "      integer, parameter:: P_MASK_SPHERE = 0\n";
print PARFILE "      integer, parameter:: P_MASK_CUBE = 1\n";
print PARFILE "      integer, parameter:: P_NV_REAL_SIZE = $nvsize\n";
if ($xptderivs) {
  print PARFILE "      integer, parameter:: P_POINT_WISE_DERIVATIVES = 0\n";
}
else {
  print PARFILE "      integer, parameter:: P_POINT_WISE_DERIVATIVES = 1\n";
}
if ($usealtcoords) {
  print PARFILE "      integer, parameter:: P_ENABLE_ALT_COORDS = 1\n";
}
else {
  print PARFILE "      integer, parameter:: P_ENABLE_ALT_COORDS = 0\n";
}
if ($hyper_derivs) {
  print PARFILE "      integer, parameter:: P_HYPER_DERIVS = 1\n";
}
else {
  print PARFILE "      integer, parameter:: P_HYPER_DERIVS = 0\n";
}
if ($hyper_rhs1) {
  print PARFILE "      integer, parameter:: P_HYPER_RHS1 = 1\n";
}
else {
  print PARFILE "      integer, parameter:: P_HYPER_RHS1 = 0\n";
}
if ($hyper_rhs2) {
  print PARFILE "      integer, parameter:: P_HYPER_RHS2 = 1\n";
}
else {
  print PARFILE "      integer, parameter:: P_HYPER_RHS2 = 0\n";
}




print PARFILE "      integer, parameter:: P_STENCIL_X_CENTER       = 0\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_LEFT         = 10000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_CENTER_LEFT  = 20000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_CENTER_RIGHT = 30000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_RIGHT        = 40000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_EDGE_P       = 50000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_EDGE_M       = 60000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_VERTEX_P     = 70000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_VERTEX_M     = 80000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_MASK         = 90000\n";
print PARFILE "      integer, parameter:: P_STENCIL_X_UNDEF        = 100000\n";

print PARFILE "      integer, parameter:: P_STENCIL_Y_CENTER       = 0\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_LEFT         = 100\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_CENTER_LEFT  = 200\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_CENTER_RIGHT = 300\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_RIGHT        = 400\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_EDGE_P       = 500\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_EDGE_M       = 600\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_VERTEX_P     = 700\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_VERTEX_M     = 800\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_MASK         = 900\n";
print PARFILE "      integer, parameter:: P_STENCIL_Y_UNDEF        = 1000\n";

print PARFILE "      integer, parameter:: P_STENCIL_Z_CENTER       = 0\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_LEFT         = 1\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_CENTER_LEFT  = 2\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_CENTER_RIGHT = 3\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_RIGHT        = 4\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_EDGE_P       = 5\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_EDGE_M       = 6\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_VERTEX_P     = 7\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_VERTEX_M     = 8\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_MASK         = 9\n";
print PARFILE "      integer, parameter:: P_STENCIL_Z_UNDEF        = 10\n";


print PARFILE "      integer, parameter:: P_STENCIL_CENTER       = 0\n";
print PARFILE "      integer, parameter:: P_STENCIL_LEFT         = 1\n";
print PARFILE "      integer, parameter:: P_STENCIL_CENTER_LEFT  = 2\n";
print PARFILE "      integer, parameter:: P_STENCIL_CENTER_RIGHT = 3\n";
print PARFILE "      integer, parameter:: P_STENCIL_RIGHT        = 4\n";
print PARFILE "      integer, parameter:: P_STENCIL_EDGE_P       = 5\n";
print PARFILE "      integer, parameter:: P_STENCIL_EDGE_M       = 6\n";
print PARFILE "      integer, parameter:: P_STENCIL_VERTEX_P     = 7\n";
print PARFILE "      integer, parameter:: P_STENCIL_VERTEX_M     = 8\n";
print PARFILE "      integer, parameter:: P_STENCIL_MASK         = 9\n";
print PARFILE "      integer, parameter:: P_STENCIL_UNDEF        = 10\n";

print PARFILE "      END MODULE PARAMS\n";
close(PARFILE);


if ($debug2) {
  print STDERR "After writing parameter file\n";
  print STDERR "u:    @u\n";
  print STDERR "du:   @du\n";
  print STDERR "v:    @v\n";
  print STDERR "dv:   @dv\n";
  print STDERR "w:    @w\n";
  print STDERR "par:  @params\n";
}





######################################################################
#
# Create the utility file
#
######################################################################

$utilfile = "util.x";
open(UFILE, ">$utilfile");

print UFILE<<EOF;
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! This is a machine-generated file.  Do not edit this file directly.
! Rather edit the hypersetup file.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include "cctk.h"

      MODULE UTILEQS
      use params
      implicit none

      CONTAINS
EOF

print UFILE "      subroutine assign_ptrs_init(";

for ($i=0; $i<=$#u; $i++) {
  print UFILE "$u[$i],";
}
for ($i=0; $i<=$#v; $i++) {
  print UFILE "$v[$i],";
}
for ($i=0; $i<=$#w; $i++) {
  print UFILE "$w[$i],";
}
print UFILE "u0, v, w,nx,ny,nz)\n";

print UFILE<<EOF;
      use GF
      implicit none
      integer :: nx,ny,nz
      type(gridfunction), dimension(NU) :: u0
      type(gridfunction), dimension(NV) :: v
      type(gridfunction), dimension(NW) :: w

EOF

for ($i=0; $i<=$#u; $i++) {
  print UFILE "      CCTK_REAL $u[$i](nx,ny,nz)\n";
}
for ($i=0; $i<=$#v; $i++) {
  print UFILE "      CCTK_REAL $v[$i](nx,ny,nz)\n";
}
for ($i=0; $i<=$#w; $i++) {
  print UFILE "      CCTK_REAL $w[$i](nx,ny,nz)\n";
}



foreach $e (@u) {
  print UFILE "      target :: $e\n";
}
foreach $e (@v) {
  print UFILE "      target :: $e\n";
}
foreach $e (@w) {
  if (!($usealtcoords ==0 && $e =~ /[xyz]phys/)) {
    print UFILE "      target :: $e\n";
  }
}

foreach $e (@u) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "      u0(H_$e1)%d => $e\n";
}

for($i = 0; $i <= $#u; $i++) {
  $e = $u[$i];
  $e =~ tr/a-z/A-Z/;
  print UFILE "      u0(H_$e)%excise_val = $u_exc_val[$i]\n";
  print UFILE "      u0(H_$e)%farlimit_val = $u_farlimit_val[$i]\n";
  print UFILE "      u0(H_$e)%falloff_val = $u_falloff_val[$i]\n";
  print UFILE "      u0(H_$e)%pspeed_val = $u_pspeed_val[$i]\n";
  if ($n_dxu[$i]) {
    print UFILE "      u0(H_$e)%take_dx = 1\n";
  }
  else {
    print UFILE "      u0(H_$e)%take_dx = 0\n";
  }
  if ($n_dyu[$i]) {
    print UFILE "      u0(H_$e)%take_dy = 1\n";
  }
  else {
    print UFILE "      u0(H_$e)%take_dy = 0\n";
  }
  if ($n_dzu[$i]) {
    print UFILE "      u0(H_$e)%take_dz = 1\n";
  }
  else {
    print UFILE "      u0(H_$e)%take_dz = 0\n";
  }
}

foreach $e (@v) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "      v(H_$e1)%d => $e\n";
}
# The code assumes that there is always at least one element in u, v, and w.
# If any list is empty, the pointer for element one must be nullified
# to avoid segmentation faults in various parts of the code.  (Practically
# u is never empty (what point in running code then?) and w is never empty
# (it contains the coordinates), so we only check v.
if ($#v < 0) {
  print UFILE "      nullify(v(1)%d)\n";
}


foreach $e (@w) {
  $e1 = $e;
  $e1 =~ s/cctk_//;
  $e1 =~ tr/a-z/A-Z/;
  if ($e1 =~ /[XYZ]PHYS/ && $usealtcoords==0) {
    $e2 = $e;
    $e2 =~ s/phys//;
    print UFILE "      w(H_$e1)%d => cctk_$e2\n";
  }
  else {
    print UFILE "      w(H_$e1)%d => $e\n";
  }
}

print UFILE<<EOF;
      return
      end subroutine assign_ptrs_init

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Assign_ptrs_fields
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
EOF
print UFILE "      subroutine assign_ptrs_fields(";
for ($i=0; $i<=$#u; $i++) {
  $n1 = $u[$i];
  $n2 = $n1 . "_np1";
  print UFILE "$n1, $n2,";
}
for ($i=0; $i<=$#v; $i++) {
  print UFILE "$v[$i],";
}
for ($i=0; $i<=$#w; $i++) {
  print UFILE "$w[$i],";
}
print UFILE "u2, u0, v, w, nx, ny, nz)\n";
print UFILE<<EOF;
      use GF
      implicit none

      integer :: nx, ny, nz
      type(gridfunction), dimension(NU) :: u2, u0
      type(gridfunction), dimension(NW) :: w
      type(gridfunction), dimension(NV) :: v
EOF

for ($i=0; $i<=$#u; $i++) {
  $n1 = $u[$i];
  $n2 = $n1 . "_np1";
  print UFILE "      CCTK_REAL $n1(nx,ny,nz),$n2(nx,ny,nz)\n";
}
for ($i=0; $i<=$#v; $i++) {
  print UFILE "      CCTK_REAL $v[$i](nx,ny,nz)\n";
}
for ($i=0; $i<=$#w; $i++) {
  print UFILE "      CCTK_REAL $w[$i](nx,ny,nz)\n";
}


foreach $e (@u) {
  $ee = $e . "_np1";
  print UFILE "      target :: $e, $ee\n";
}
foreach $e (@w) {
  if (!($usealtcoords ==0 && $e =~ /[xyz]phys/)) {
    print UFILE "      target :: $e\n";
  }
}
foreach $e (@v) {
  print UFILE "      target :: $e\n";
}

print UFILE "\n\n";
foreach $e (@u) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "      u0(H_$e1)%d => $e\n";
  print UFILE "      u2(H_$e1)%d => $e";
  print UFILE "_np1\n";
}

foreach $e (@v) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "      v(H_$e1)%d => $e\n";
}
# The code assumes that there is always at least one element in u, v, and w.
# If any list is empty, the pointer for element one must be nullified
# to avoid segmentation faults in various parts of the code.  (Practically
# u is never empty (what point in running code then?) and w is never empty
# (it contains the coordinates), so we only check v.
if ($#v < 0) {
  print UFILE "      nullify(v(1)%d)\n";
}

foreach $e (@w) {
  $e1 = $e;
  $e1 =~ s/cctk_//;
  $e1 =~ tr/a-z/A-Z/;
  if ($e1 =~ /[XYZ]PHYS/ && $usealtcoords==0) {
    $e2 = $e;
    $e2 =~ s/phys//;
    print UFILE "      w(H_$e1)%d => cctk_$e2\n";
  }
  else {
    print UFILE "      w(H_$e1)%d => $e\n";
  }
}



for($i = 0; $i <= $#u; $i++) {
  $e = $u[$i];
  $e =~ tr/a-z/A-Z/;
  print UFILE "      u0(H_$e)%excise_val = $u_exc_val[$i]\n";
  print UFILE "      u2(H_$e)%excise_val = $u_exc_val[$i]\n";
  print UFILE "      u0(H_$e)%farlimit_val = $u_farlimit_val[$i]\n";
  print UFILE "      u2(H_$e)%farlimit_val = $u_farlimit_val[$i]\n";
  print UFILE "      u0(H_$e)%falloff_val = $u_falloff_val[$i]\n";
  print UFILE "      u2(H_$e)%falloff_val = $u_falloff_val[$i]\n";
  print UFILE "      u0(H_$e)%pspeed_val = $u_pspeed_val[$i]\n";
  print UFILE "      u2(H_$e)%pspeed_val = $u_pspeed_val[$i]\n";

  if ($n_dxu[$i]) {
    print UFILE "      u2(H_$e)%take_dx = 1\n";
    print UFILE "      u0(H_$e)%take_dx = 1\n";
  }
  else {
    print UFILE "      u2(H_$e)%take_dx = 0\n";
    print UFILE "      u0(H_$e)%take_dx = 0\n";
  }
  if ($n_dyu[$i]) {
    print UFILE "      u2(H_$e)%take_dy = 1\n";
    print UFILE "      u0(H_$e)%take_dy = 1\n";
  }
  else {
    print UFILE "      u2(H_$e)%take_dy = 0\n";
    print UFILE "      u0(H_$e)%take_dy = 0\n";
  }
  if ($n_dzu[$i]) {
    print UFILE "      u2(H_$e)%take_dz = 1\n";
    print UFILE "      u0(H_$e)%take_dz = 1\n";
  }
  else {
    print UFILE "      u2(H_$e)%take_dz = 0\n";
    print UFILE "      u0(H_$e)%take_dz = 0\n";
  }
}

for($i = 0; $i <= $#v; $i++) {
  $e = $v[$i];
  $e =~ tr/a-z/A-Z/;
  if ($n_dxv[$i]) {
    print UFILE "      v(H_$e)%take_dx = 1\n";
  }
  else {
    print UFILE "      v(H_$e)%take_dx = 0\n";
  }
  if ($n_dyv[$i]) {
    print UFILE "      v(H_$e)%take_dy = 1\n";
  }
  else {
    print UFILE "      v(H_$e)%take_dy = 0\n";
  }
  if ($n_dzv[$i]) {
    print UFILE "      v(H_$e)%take_dz = 1\n";
  }
  else {
    print UFILE "      v(H_$e)%take_dz = 0\n";
  }
}
if ($#v < 0) {
    print UFILE "      v(1)%take_dx = 0\n";
    print UFILE "      v(1)%take_dy = 0\n";
    print UFILE "      v(1)%take_dz = 0\n";
}

print UFILE<<EOF;
      return
      end subroutine assign_ptrs_fields


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Assign_ptrs_rks
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
EOF
print UFILE "      subroutine assign_ptrs_rks(";
for ($i=0; $i<=$#u; $i++) {
  $n = $u[$i];
  $n1 = $n . "_rk1";
  $n2 = $n . "_rk2";
  $n3 = $n . "_rk3";
  print UFILE "$n1, $n2, $n3,";
}


print UFILE "urk1,urk2,urk3,nx,ny,nz)\n";
print UFILE<<EOF;
      use GF
      implicit none

       integer   :: nx, ny, nz
      type(gridfunction), dimension(NU) :: urk1,urk2,urk3

EOF

for ($i=0; $i<=$#u; $i++) {
  $n = $u[$i];
  $n1 = $n . "_rk1";
  $n2 = $n . "_rk2";
  $n3 = $n . "_rk3";
  print UFILE "      CCTK_REAL $n1(nx,ny,nz)\n";
  print UFILE "      CCTK_REAL $n2(nx,ny,nz)\n";
  print UFILE "      CCTK_REAL $n3(nx,ny,nz)\n";
}


foreach $e (@u) {
  $e1 = $e . "_rk1";
  $e2 = $e . "_rk2";
  $e3 = $e . "_rk3";
  print UFILE "        target :: $e1, $e2, $e3\n";
}

foreach $e (@u) {
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "        urk1(H_$e1)%d => $e";
  print UFILE "_rk1\n";
  print UFILE "        urk2(H_$e1)%d => $e";
  print UFILE "_rk2\n";
  print UFILE "        urk3(H_$e1)%d => $e";
  print UFILE "_rk3\n";
}

print UFILE<<EOF;
      return
      end subroutine assign_ptrs_rks

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Assign_ptrs_derivs
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

EOF
print UFILE "      subroutine assign_ptrs_derivs(";
foreach $e (@du) {
  print UFILE "$e,";
}
foreach $e (@dv) {
  print UFILE "$e,";
}
print UFILE "dxu, dyu, dzu, dxv, dyv, dzv, nx, ny, nz)\n";
print UFILE<<EOF;
      use GF
      implicit none
    
      integer :: nx, ny, nz
      type(gridfunction), dimension(NU) :: dxu, dyu, dzu
      type(gridfunction), dimension(NV) :: dxv, dyv, dzv

EOF

foreach $e (@du) {
  print UFILE "      CCTK_REAL $e(nx,ny,nz)\n";
}
foreach $e (@dv) {
  print UFILE "      CCTK_REAL $e(nx,ny,nz)\n";
}


if ($xptderivs) {
  foreach $e (@du) {
    print UFILE "      target :: $e\n";
  }
  foreach $e (@dv) {
    print UFILE "      target :: $e\n";
  }
}

for($i = 0; $i <= $#u; $i++) {
  $e = $u[$i];
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  if ($n_dxu[$i] && $xptderivs) {
    print UFILE "      dxu(H_$e1)%d => dx_$e\n";
  }
  else {
    print UFILE "      nullify(dxu(H_$e1)%d)\n";
  }
  if ($n_dyu[$i] && $xptderivs) {
    print UFILE "      dyu(H_$e1)%d => dy_$e\n";
  }
  else {
    print UFILE "      nullify(dyu(H_$e1)%d)\n";
  }
  if ($n_dzu[$i] && $xptderivs) {
    print UFILE "      dzu(H_$e1)%d => dz_$e\n";
  }
  else {
    print UFILE "      nullify(dzu(H_$e1)%d)\n";
  }
}

for($i = 0; $i <= $#v; $i++) {
  $e = $v[$i];
  $e1 = $e;
  $e1 =~ tr/a-z/A-Z/;
  if ($n_dxv[$i] && $xptderivs) {
    print UFILE "      dxv(H_$e1)%d => dx_$e\n";
  }
  else {
    print UFILE "      nullify(dxv(H_$e1)%d)\n";
  }
  if ($n_dyv[$i] && $xptderivs) {
    print UFILE "      dyv(H_$e1)%d => dy_$e\n";
  }
  else {
    print UFILE "      nullify(dyv(H_$e1)%d)\n";
  }
  if ($n_dzv[$i] && $xptderivs) {
    print UFILE "      dzv(H_$e1)%d => dz_$e\n";
  }
  else {
    print UFILE "      nullify(dzv(H_$e1)%d)\n";
  }
}
if ($#v < 0) {
    print UFILE "      nullify(dxv(1)%d)\n";
    print UFILE "      nullify(dyv(1)%d)\n";
    print UFILE "      nullify(dzv(1)%d)\n";
}




print UFILE<<EOF;
      return
      end subroutine assign_ptrs_derivs

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Assign_params
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

EOF
print UFILE "      subroutine assign_params(";
foreach $e (@params) {
  print UFILE "$e,";
}
print UFILE "hg,dtg,minx,miny,minz,maxx,maxy,maxz,time,par)\n";
print UFILE<<EOF;
      implicit none


      CCTK_REAL, dimension(NPAR) :: par
      CCTK_REAL  hg,dtg,minx,miny,minz,maxx,maxy,maxz,time


EOF

for ($i = 0; $i <= $#params; $i++) {
  if ($params_type[$i] eq "int") {
    print UFILE "       CCTK_INT $params[$i]\n";
  }
  elsif ($params_type[$i] eq "double") {
    print UFILE "       CCTK_REAL $params[$i]\n";
  }
}
print UFILE<<EOF;
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !
      ! Equation thorn parameters
      !
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
      global_nx = nx0
      global_ny = ny0
      global_nz = nz0
      !if (minx .gt. minx0) then
      !  bbox1 = 0
      !else
      !  bbox1 = 1
      !end if
      !if (maxx .lt. maxx0) then
      !  bbox2 = 0
      !else
      !  bbox2 = 1
      !end if
      !if (miny .gt. miny0) then
      !  bbox3 = 0
      !else
      !  bbox3 = 1
      !end if
      !if (maxy .lt. maxy0) then
      !  bbox4 = 0
      !else
      !  bbox4 = 1
      !end if
      !if (minz .gt. minz0) then
      !  bbox5 = 0
      !else
      !  bbox5 = 1
      !end if
      !if (maxz .lt. maxz0) then
      !  bbox6 = 0
      !else
      !  bbox6 = 1
      !end if
    
    


      dt = dt
      dx = h
      dy = h
      dz = h
      nghostzones_x = bound_width
      nghostzones_y = bound_width
      nghostzones_z = bound_width
      local_time = time

EOF

foreach $e (@params) {
  $e1 = $e;
  $e1 =~ s/local_//;
  $e1 =~ tr/a-z/A-Z/;
  print UFILE "      par(P_$e1) = $e\n";
}


#
# SLL 10/2/04: HACK: certain parameters
#              are specific to the grid
#              I'm not sure the best way
#              to put these in
#
print UFILE<<EOF;

      par(P_H) = hg
      par(P_DX) = hg
      par(P_DY) = hg
      par(P_DZ) = hg
      par(P_DT) = dtg


      return
      end subroutine assign_params

      !-------------------------------------------------------------------
      !
      !   check each face of the cubical grid to see if it is a physical
      !   boundary
      !
      !-------------------------------------------------------------------
      subroutine set_bbox(bbox1, bbox2, bbox3, bbox4, bbox5, bbox6,
     &                    chr, nx, ny, nz)
      implicit none

      integer bbox1, bbox2, bbox3, bbox4, bbox5, bbox6
      integer  nx, ny, nz
      CCTK_REAL  chr(nx,ny,nz)

      ! local vars
      integer   nxm, nym, nzm

      nxm = nx/2
      nym = ny/2
      nzm = nz/2

      ! check xmin face
      if (nint(chr(1, nym, nzm)) .eq. 2) then
         bbox1 = 1
      else
         bbox1 = 0
      end if

      ! check xmax face
      if (nint(chr(nx, nym, nzm)) .eq. 3) then
         bbox2 = 1
      else
         bbox2 = 0
      end if

      ! check ymin face
      if (nint(chr(nxm, 1, nzm)) .eq. 4) then
         bbox3 = 1
      else
         bbox3 = 0
      end if

      ! check ymax face
      if (nint(chr(nxm, ny, nzm)) .eq. 5) then
         bbox4 = 1
      else
         bbox4 = 0
      end if

      ! check zmin face
      if (nint(chr(nxm, nym, 1)) .eq. 6) then
         bbox5 = 1
      else
         bbox5 = 0
      end if

      ! check zmax face
      if (nint(chr(nxm, nym, nz)) .eq. 7) then
         bbox6 = 1
      else
         bbox6 = 0
      end if

      return
      end subroutine set_bbox

      END MODULE UTILEQS
EOF



close(UFILE);

########################################################################
#
# Create the type.x file
#
########################################################################

$typefile = "type.x";
open(TFILE, ">$typefile");

print TFILE<<EOF;

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! This is a machine-generated file.  Do not edit this file directly.
! Rather edit the hyperfcn file or the hypersetup script.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include "cctk.h"


        MODULE GF
        implicit none

        type gridfunction
        CCTK_REAL, dimension(:,:,:), pointer :: d
        CCTK_INT     :: take_dx, take_dy, take_dz
        CCTK_REAL    :: excise_val
        CCTK_REAL    :: farlimit_val
        CCTK_REAL    :: falloff_val
        CCTK_REAL    :: pspeed_val
        end type gridfunction

        end MODULE GF
EOF

close(TFILE);


########################################################################
#
# Create the func.inc file
#
########################################################################

#
#  The total number of fields is the sum of nv, nu, and nw PLUS 1 for the tmp.
#
$nf = 5*$nu + $nv + $nw + $ndu + $ndv + 1;

$fieldfile = "fields.inc";
print "opening $fieldfile\n";
open(FFILE, ">$fieldfile");

print FFILE<<EOF;

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! This is a machine-generated file.  Do not edit this file directly.
! Rather edit the hyperfcn file or the hypersetup script.
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      integer num_gfuncs
EOF
print FFILE "      parameter(num_gfuncs=$nf)\n";

print FFILE<<EOF;
      integer GFUNC_INTEGRAL,
     &                 GFUNC_INTEGRAL_ADV,
     &                 GFUNC_DERIVED,
     &                 GFUNC_STATIC,
     &                 GFUNC_TEMP,
     &                 GFUNC_INTEGRAL_DER
           parameter ( GFUNC_INTEGRAL     = 0,
     &                 GFUNC_INTEGRAL_ADV = 1,
     &                 GFUNC_DERIVED      = 2,
     &                 GFUNC_STATIC       = 3,
     &                 GFUNC_TEMP         = 4,
     &                 GFUNC_INTEGRAL_DER = 5   )

!
!
!          Explanation of field types:
!             GFUNC_INTEGRAL     --- fields which are evolved, and therefore must have
!                                    a corresponding _np1 field numerical next in the order
!                                    They get: initialized from siblings/parents,
!                                    injected to parents, and synced w/ siblings. They also
!                                    have boundary data interpolated in time/space from parents.
!                                    These correspond to the "u" fields in a setup file.
!             GFUNC_INTEGRAL_ADV --- the _np1 data correspond to the previous
!             GFUNC_INTEGRAL_DER --- fields integral to the evolution, but which are not 
!                                    evolved. They also get: initialized from siblings/parents,
!                                    injected to parents, and synced w/ siblings. They do not
!                                    get boundary data interpolated in time since their parents
!                                    don't have two time levels.
!                                    These correspond to the "v" fields in a setup file.
!             GFUNC_DERIVED      --- Associated fields not integral to the integration.
!                                    These correspond to the "w" fields in a setup file.
!
!
!
!
      character(128) gfunc_name(num_gfuncs)
      integer     gfunc_type(num_gfuncs),
     *            gfunc_out(num_gfuncs),
     *            gfunc_tmpptr(num_gfuncs),
     *            gfunc_pointer(num_gfuncs,maxnumgrids)

      common  / gfunc_ints / gfunc_pointer, gfunc_tmpptr, gfunc_out

EOF

@usuf = ("", "_np1", "_rk1", "_rk2", "_rk3");
@utype= ("GFUNC_INTEGRAL", "GFUNC_INTEGRAL_ADV");
$if = 0;
foreach $e (@u) {
  #$basename = substr($e,0,10);
  $basename = $e;

  for ($i=0; $i < 2; $i++) {
    $if++;
    $s = $usuf[$i];
    $type = $utype[$i];
    $name = $basename . $s;
    $ptn = "gr_" . $name;
    print FFILE "      data gfunc_name($if) / '$name' /\n";
    print FFILE "      data gfunc_type($if) /  $type /\n";
    print FFILE "      integer $ptn\n";
    print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
  }
}

foreach $e (@u) {
  $basename = $e;
  for ($i=2; $i < 5; $i++) {
    $if++;
    $s = $usuf[$i];
    $type = $utype[$i];
    $name = $basename . $s;
    $ptn = "gr_" . $name;
    print FFILE "      data gfunc_name($if) / '$name' /\n";
    print FFILE "      data gfunc_type($if) /  GFUNC_DERIVED/\n";
    #print FFILE "      data gfunc_type($if) /  GFUNC_INTEGRAL_ADV/\n";
    print FFILE "      integer $ptn\n";
    print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
  }
}

foreach $e (@du) {
  $if++;
  $name = $e;
  #$name = substr($e,0,10);
  $ptn = "gr_" . $name;
  print FFILE "      data gfunc_name($if) / '$name' /\n";
  print FFILE "      data gfunc_type($if) /  GFUNC_DERIVED/\n";
  print FFILE "      integer $ptn\n";
  print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
}


foreach $e (@v) {
  $if++;
  $name = $e;
  #$name = substr($e,0,10);
  $ptn = "gr_" . $name;
  print FFILE "      data gfunc_name($if) / '$name' /\n";
  print FFILE "      data gfunc_type($if) /  GFUNC_INTEGRAL_DER/\n";
  #print FFILE "      data gfunc_type($if) /  GFUNC_DERIVED/\n";
  print FFILE "      integer $ptn\n";
  print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
}

foreach $e (@dv) {
  $if++;
  $name = $e;
  #$name = substr($e,0,10);
  $ptn = "gr_" . $name;
  print FFILE "      data gfunc_name($if) / '$name' /\n";
  print FFILE "      data gfunc_type($if) /  GFUNC_DERIVED/\n";
  print FFILE "      integer $ptn\n";
  print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
}


foreach $e (@w) {
  $if++;
  $name = $e;
  #$name = substr($e,0,10);
  $ptn = "gr_" . $name;
  print FFILE "      data gfunc_name($if) / '$name' /\n";
  print FFILE "      data gfunc_type($if) /  GFUNC_DERIVED/\n";
  print FFILE "      integer $ptn\n";
  print FFILE "      equivalence (gfunc_tmpptr($if), $ptn)\n\n";
}

#
#  tmp must be here
#
$if++;
print FFILE "      data gfunc_name($if) / 'gr_tmp' /\n";
print FFILE "      data gfunc_type($if) /  GFUNC_TEMP /\n";
print FFILE "      integer gr_tmp\n";
print FFILE "      equivalence (gfunc_tmpptr($if), gr_tmp)\n\n";


close(FFILE);



########################################################################
#
# Create I/O routines  -- 
#
########################################################################

$iofile = "param.inc";
print "opening $iofile\n";
open(IOFILE, ">$iofile");
print IOFILE<<EOF;

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! This is a machine-generated file.  Do not edit this file directly.
! Rather edit the hyperfcn file or the hypersetup script.
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

EOF
@common_int=();
@common_real=();
for ($i=0; $i<=$#par; $i++) {
  if ($par_type[$i] eq "int") {
    print IOFILE "      integer $par[$i]\n";
    push(@common_int, $par[$i]);
  }
  elsif ($par_type[$i] eq "double") {
    print IOFILE "      real(kind=8) $par[$i]\n";
    push(@common_real, $par[$i]);
  }
}
#
#  The common block should list the doubles first, then the ints for
#  better performance.
#
print IOFILE "      common / use_params / ";
for ($i=0; $i<=$#common_real; $i++) {
  print IOFILE "$common_real[$i],";
}
for ($i=0; $i<$#common_int; $i++) {
  print IOFILE "$common_int[$i],";
}
print IOFILE "$common_int[$#common_int]\n";

close(IOFILE);



$iofile = "hyperio.x";
print "opening $iofile\n";
open(IOFILE, ">$iofile");

print IOFILE<<EOF;

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! This is a machine-generated file.  Do not edit this file directly.
! Rather edit the hyperfcn file or the hypersetup script.
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#include "cctk.h"


!----------------------------------------------------------------------
!  Subroutine params_dump  
!----------------------------------------------------------------------
      subroutine params_dump( )
      implicit   none
      include   'grid.inc'
      include   'glob.inc'
      include   'param.inc'
      integer    i

EOF

for ($i=0; $i<=$#params; $i++) {
  print IOFILE "      write(*,*)'      $params[$i]   = ',$params[$i]\n";
}


print IOFILE<<EOF;
      do i = 1, num_gfuncs
         write(*,*) '           gfunc_out(',i,') = ',gfunc_out(i)
      end do
      do i = 0, maxlev - 1
        write(*,*) '           out_period(',i,') = ', out_period(i)
      end do
      do i = 0, maxlev - 1
        write(*,*) '            ref_level(',i,') = ', ref_level(i)
      end do

      return
      end  

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!c                                                                            cc
!c  params_read:                                                              cc
!c                   Read in parameters from file given as argument.          cc
!c                   Sets default values, and then reads in from file.        cc
!c                   Problem specific routine.                                cc
!c                                                                            cc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine params_read( pfile )
      implicit     none
      character(64) pfile
      include     'grid.inc'
      include     'glob.inc'
      include     'param.inc'
      integer      fileunum,
     *             rc,
     *             i,
     *             LARGEINT
      parameter (  LARGEINT = 999999999 )
      integer      err

c     function declarations
      integer    get_int_param, get_real_param, get_str_param
EOF

@usuf=("", "_np1", "_rk1", "_rk2", "_rk3");
for ($i=0; $i<=$#u; $i++) {
  foreach $e (@usuf) {
    $zz = $u[$i] . $e;
    $zzo = "output_" . $zz;
    print IOFILE "      integer $zzo\n";
  }
}

for ($i=0; $i<=$#du; $i++) {
  $zz = $du[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      integer $zzo\n";
}

for ($i=0; $i<=$#v; $i++) {
  $zz = $v[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      integer $zzo\n";
}

for ($i=0; $i<=$#dv; $i++) {
  $zz = $dv[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      integer $zzo\n";
}


for ($i=0; $i<=$#w; $i++) {
  $zz = $w[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      integer $zzo\n";
}

for ($i=0; $i <= $MAXLEVELS; $i++) {
  $zzo = "output_level_" . $i;
  print IOFILE "      integer $zzo\n";
}

for ($i=0; $i <= $MAXLEVELS; $i++) {
  $zzo = "refine_level_" . $i;
  print IOFILE "      real(kind=8) $zzo\n";
  #print IOFILE "      integer $zzo\n";
}





print IOFILE<<EOF;

      err = 0

      fileunum = 8
      open(unit=fileunum,file=pfile,status='old',iostat=rc)
      if(rc .ne. 0) then
        write(*,*) 'params_read: Unable to open parameter file: ',pfile
        call my_exit('Unable to open file.')
      end if

EOF

#
#  read the parameters
#
for ($i=0; $i<=$#params; $i++) {
  if ($params_type[$i] eq "int") {
    print IOFILE "      rc = get_int_param(pfile,'$params[$i]',$params[$i],$params_size[$i])\n";
  }
  elsif ($params_type[$i] eq "double") {
    print IOFILE "      rc = get_real_param(pfile,'$params[$i]',$params[$i],$params_size[$i])\n";
  }
  print IOFILE "      if (rc.ne.1) then\n";
  print IOFILE "        $params[$i] = $params_val[$i]\n";
  print IOFILE "      end if\n";
  if ($params_vmin[$i] eq "*") {
  }
  else {
    print IOFILE "      if ($params[$i] .lt. $params_vmin[$i]) then\n";
    print IOFILE "        write(0,*)'Error: $params[$i] too small. Min value = $par_vmin[$i]',$params[$i]\n";
    print IOFILE "        err = err + 1\n";
    print IOFILE "      end if\n";
  }
  if ($params_vmax[$i] eq "*") {
  }
  else {
    print IOFILE "      if ($params[$i] .gt. $params_vmax[$i]) then\n";
    print IOFILE "        write(0,*)'Error: $params[$i] too big. Max value = $par_vmax[$i]',$params[$i]\n";
    print IOFILE "        err = err + 1\n";
    print IOFILE "      end if\n";
  }

}

@usuf=("", "_np1");
$if = 0;
for ($i=0; $i<=$#u; $i++) {
  foreach $e (@usuf) {
    $if++;
    $zz = $u[$i] . $e;
    $zzo = "output_" . $zz;
    print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
    print IOFILE "      if (rc .ne. 1) then\n";
    print IOFILE "        $zzo = 0\n";
    print IOFILE "      end if\n";
    print IOFILE "      gfunc_out($if) = $zzo\n";
  }
}
@usuf2 = ("_rk1", "_rk2", "_rk3");
for ($i=0; $i<=$#u; $i++) {
  foreach $e (@usuf2) {
    $if++;
    $zz = $u[$i] . $e;
    $zzo = "output_" . $zz;
    print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
    print IOFILE "      if (rc .ne. 1) then\n";
    print IOFILE "        $zzo = 0\n";
    print IOFILE "      end if\n";
    print IOFILE "      gfunc_out($if) = $zzo\n";
  }
}
for ($i=0; $i<=$#du; $i++) {
  $if++;
  $zz = $du[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 0\n";
  print IOFILE "      end if\n";
  print IOFILE "      gfunc_out($if) = $zzo\n";
}
for ($i=0; $i<=$#v; $i++) {
  $if++;
  $zz = $v[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 0\n";
  print IOFILE "      end if\n";
  print IOFILE "      gfunc_out($if) = $zzo\n";
}
for ($i=0; $i<=$#dv; $i++) {
  $if++;
  $zz = $dv[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 0\n";
  print IOFILE "      end if\n";
  print IOFILE "      gfunc_out($if) = $zzo\n";
}
for ($i=0; $i<=$#w; $i++) {
  $if++;
  $zz = $w[$i];
  $zzo = "output_" . $zz;
  print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 0\n";
  print IOFILE "      end if\n";
  print IOFILE "      gfunc_out($if) = $zzo\n";
}

for ($i=0; $i <= $MAXLEVELS-1; $i++) {
  $zzo = "output_level_" . $i;
  print IOFILE "      rc = get_int_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 0\n";
  print IOFILE "      end if\n";
  print IOFILE "      out_period($i) = $zzo\n";
  #
  $zzo = "refine_level_" . $i;
  print IOFILE "      rc = get_real_param(pfile,'$zzo',$zzo,1)\n";
  print IOFILE "      if (rc .ne. 1) then\n";
  print IOFILE "        $zzo = 1.d0\n";
  print IOFILE "      end if\n";
  print IOFILE "      ref_level($i) = $zzo\n";
}

print IOFILE "      rc = get_str_param(pfile, 'tag', tag, 3)\n";
print IOFILE "      if (rc .ne. 1) then\n";
print IOFILE "        tag = ''\n";
print IOFILE "      end if\n";

print IOFILE<<EOF;

      if (refine_period.eq.0) then
         refine_period = LARGEINT
         write(*,*) 'params_read: Assuming a zero refine_period'
         write(*,*) 'params_read: indicates never refine.'
         write(*,*) 'params_read: Resetting to: ',refine_period
      end if

      if (err .gt. 0) then
        write(0,*)'params_read: Problem reading in parameters'
        call my_exit('Problem reading in parameters')
      end if

      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!c                                                                            cc
!c  params_pack:                                                              cc
!c       Pack user input parameters into arrays for easy and quick            cc
!c       broadcast to the other (non-master) processes.                       cc
!c                                                                            cc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine params_pack()
       implicit     none
       include     'glob.inc'
       include     'param.inc'
       include     'mpif.h'
       include     'mpi_stuff.inc'


EOF

$ii = 0;
$id = 0;
for ($i=0; $i<=$#params; $i++) {
  if ($params_type[$i] eq "int") {
    $ii++;
    print IOFILE "      tmp_ints($ii) = $params[$i]\n";
  }
  elsif ($params_type[$i] eq "double") {
    $id++;
    print IOFILE "      tmp_dbls($id) = $params[$i]\n";
  }
}
print IOFILE<<EOF;

      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!c                                                                            cc
!c  params_bcast:                                                             cc
!c       Broadcast and unpack parameters so that all procs                    cc
!c       have them stored in their various variables in the *.inc files.      cc
!c                                                                            cc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine params_bcast()
       implicit     none
       include     'glob.inc'
       include     'grid.inc'
       include     'param.inc'
       include     'mpif.h'
       include     'mpi_stuff.inc'

       integer     taglength, mystringlength
       character(4) tmp

       integer     num_ints, num_dbls

EOF

print IOFILE "      num_ints = $ii\n";
print IOFILE "      num_dbls = $id\n";

print IOFILE<<EOF;

       if (num_ints .gt. num_int_params) then
          write(*,*) 'params_bcast: Problem! Increase num_int_params. '
          write(*,*) 'params_bcast: num_ints       = ',num_ints
          write(*,*) 'params_bcast: num_int_params = ',num_int_params
          call my_exit('Incrase num_int_params')
       end if
       if (num_dbls .gt. num_dbl_params) then
          write(*,*) 'params_bcast: Problem! Increase num_dbl_params. '
          write(*,*) 'params_bcast: num_dbls       = ',num_dbls
          write(*,*) 'params_bcast: num_dbl_params = ',num_dbl_params
          call my_exit('Incrase num_dbl_params')
       end if
       call MPI_BCAST(tmp_dbls,  num_dbls,    MPI_DOUBLE_PRECISION,
     &                master,    MPI_COMM_WORLD, ierr)
       call MPI_BCAST(tmp_ints,  num_ints,    MPI_INTEGER,
     &                master,    MPI_COMM_WORLD, ierr)
       call MPI_BCAST(gfunc_out, num_gfuncs,  MPI_INTEGER,
     &                master,    MPI_COMM_WORLD, ierr)
       call MPI_BCAST(out_period,maxlev,      MPI_INTEGER,
     &                master,    MPI_COMM_WORLD, ierr)
       call MPI_BCAST(ref_level, maxlev,      MPI_DOUBLE_PRECISION,
     &                master,    MPI_COMM_WORLD, ierr)
       call MPI_BCAST(tag,       4,           MPI_CHARACTER,
     &                master,    MPI_COMM_WORLD, ierr)

       call int2str(myid,tag)
EOF

$ii=0;
$id=0;
for ($i=0; $i<=$#params; $i++) {
  if ($params_type[$i] eq "int") {
    $ii++;
    print IOFILE "      $params[$i] = tmp_ints($ii)\n";
  }
  elsif ($params_type[$i] eq "double") {
    $id++;
    print IOFILE "      $params[$i] = tmp_dbls($id)\n";
  }
}

print IOFILE<<EOF;
      hx     =  ( maxx0 - minx0 ) / (nx0-1.d0)
      hy     =  ( maxy0 - miny0 ) / (ny0-1.d0)
      hz     =  ( maxz0 - minz0 ) / (nz0-1.d0)
      dt     =  lambda * hx
      h      =  hx

       return
       end     ! END: params_bcast()

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!c                                                                            cc
!c  grid_iter:                                                                cc
!c                                                                            cc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine grid_iter( gridnum )
      use params
      use GF
      use utileqs
      use hypercoords
      implicit    none
      integer     gridnum
      include    'grid.inc'
      include    'glob.inc'
      include    'param.inc'
      include    'chr.inc'
      integer    nx, ny, nz, i
      real(kind=8) minx, miny, minz, maxx, maxy, maxz
      real(kind=8) hg,  dtg, factor, time
      logical     ltrace
      parameter ( ltrace = .false. )

      type(gridfunction), dimension(NU):: u0,u2, urk1,urk2,urk3, dxu,dyu,dzu
      type(gridfunction), dimension(NV):: v, dxv, dyv, dzv
      type(gridfunction), dimension(NW):: w
      CCTK_REAL, dimension(NPAR)           :: par


      call load_pointers(gridnum)

      hg   = gr_h(gridnum)
      dtg  = lambda*hg
      local_nx   = gr_nx(gridnum)
      local_ny   = gr_ny(gridnum)
      local_nz   = gr_nz(gridnum)
      minx = gr_minx(gridnum)
      miny = gr_miny(gridnum)
      minz = gr_minz(gridnum)
      maxx = gr_maxx(gridnum)
      maxy = gr_maxy(gridnum)
      maxz = gr_maxz(gridnum)
      time = gr_t(gridnum)
      gr_iter(gridnum) = gr_iter(gridnum) + 1

      call mapCoords1dTo3d(q(gr_cctk_x), q(gr_cctk_y), q(gr_cctk_z), q(gr_x(gridnum)), q(gr_y(gridnum)), q(gr_z(gridnum)), local_nx, local_ny, local_nz)

EOF

print IOFILE "      call assign_ptrs_fields(";
for ($i=0; $i<=$#u; $i++) {
  $n1 = $u[$i];
  $n2 = $n1 . "_np1";
  print IOFILE "q(gr_$n1), q(gr_$n2),";
}
for ($i=0; $i<=$#v; $i++) {
  print IOFILE "q(gr_$v[$i]),";
}
for ($i=0; $i<=$#w; $i++) {
  print IOFILE "q(gr_$w[$i]),";
}
print IOFILE "u2, u0, v, w, local_nx, local_ny, local_nz)\n";

print IOFILE "      call assign_ptrs_rks(";
for ($i=0; $i<=$#u; $i++) {
  $n = $u[$i];
  $n1 = "gr_" . $n . "_rk1";
  $n2 = "gr_" . $n . "_rk2";
  $n3 = "gr_" . $n . "_rk3";
  print IOFILE "q($n1), q($n2), q($n3),";
}
print IOFILE "urk1, urk2, urk3, local_nx, local_ny, local_nz)\n";

print IOFILE "      call assign_ptrs_derivs(";
foreach $e (@du) {
  $n = "gr_" . $e;
  print IOFILE "q($n),";
}
foreach $e (@dv) {
  $n = "gr_" . $e;
  print IOFILE "q($n),";
}
print IOFILE "dxu, dyu, dzu, dxv, dyv, dzv, local_nx, local_ny, local_nz)\n";

print IOFILE "      call set_bbox(bbox1, bbox2, bbox3, bbox4, bbox5, bbox6, q(gr_chr), local_nx, local_ny, local_nz)\n";
print IOFILE "      call assign_params(";
foreach $e (@params) {
  print IOFILE "$e,";
}
print IOFILE "hg,dtg,minx,miny,minz,maxx,maxy,maxz,time,par)\n";

#print IOFILE "      call HyperEvolveRK(u0, u2, v, w, dxu,dyu,dzu, dxv, dyv, dzv, urk1,urk2,urk3,par)\n";
print IOFILE "      call HyperEvolveRK(u0, u2, v, w, dxu,dyu,dzu, dxv, dyv, dzv, urk1,urk2,urk3,par,gr_iter(gridnum))\n";
print IOFILE "      if (gr_iter(gridnum).eq.3) gr_iter(gridnum) = 0\n";
#print IOFILE "      call HyperAnalysis2(u0, v, w, par)\n";
print IOFILE<<EOF;
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!c                                                                            cc
!c  grid_init_t0:                                                             cc
!c                                                                            cc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine grid_init_t0( gridnum )
      use params
      use GF
      use utileqs
      use hypercoords
      implicit    none
      integer     gridnum
      include    'grid.inc'
      include    'glob.inc'
      include    'param.inc'
      include    'chr.inc'
      integer    nx, ny, nz, i
      real(kind=8)  minx, miny, minz, maxx, maxy, maxz
      real(kind=8)  hg,  dtg, factor, time
      logical     ltrace
      parameter ( ltrace = .false. )

      type(gridfunction), dimension(NU):: u0,u2
      type(gridfunction), dimension(NV):: v
      type(gridfunction), dimension(NW):: w
      CCTK_REAL, dimension(NPAR)           :: par


      call load_pointers(gridnum)

      hg   = gr_h(gridnum)
      dtg  = lambda*hg
      local_nx   = gr_nx(gridnum)
      local_ny   = gr_ny(gridnum)
      local_nz   = gr_nz(gridnum)
      minx = gr_minx(gridnum)
      miny = gr_miny(gridnum)
      minz = gr_minz(gridnum)
      maxx = gr_maxx(gridnum)
      maxy = gr_maxy(gridnum)
      maxz = gr_maxz(gridnum)
      time = gr_t(gridnum)
      call mapCoords1dTo3d(q(gr_cctk_x), q(gr_cctk_y), q(gr_cctk_z), q(gr_x(gridnum)), q(gr_y(gridnum)), q(gr_z(gridnum)), local_nx, local_ny, local_nz)
EOF

print IOFILE "      call assign_params(";
foreach $e (@params) {
  print IOFILE "$e,";
}
print IOFILE "hg,dtg,minx,miny,minz,maxx,maxy,maxz,time,par)\n";


print IOFILE "      call assign_ptrs_fields(";
for ($i=0; $i<=$#u; $i++) {
  $n1 = $u[$i];
  $n2 = $n1 . "_np1";
  print IOFILE "q(gr_$n1), q(gr_$n2),";
}
for ($i=0; $i<=$#v; $i++) {
  print IOFILE "q(gr_$v[$i]),";
}
for ($i=0; $i<=$#w; $i++) {
  print IOFILE "q(gr_$w[$i]),";
}
print IOFILE "u2, u0, v, w, local_nx, local_ny, local_nz)\n";

print IOFILE<<EOF;
      call HyperInit(u0, v, w, par)
!      call HyperAnalysis2(u0, v, w, par)
      return
      end
EOF




close(IOFILE);

##############################################################################
#
#  Create cctk.h
#
##############################################################################
$outfile = "cctk.h";
open(OFILE,">$outfile");

print OFILE<<EOF;

/*------------------------------------------------------------------------
 *
 *  \$Id: hypersetup,v 1.34 2006-07-07 04:11:19 dneilsen Exp $
 *
 *  This is a machine-generated file.  Do not edit this file directly!
 *  (You can, of course, but your changes will be lost...)
 *
 *------------------------------------------------------------------------*/
#ifndef _CCTK_H
#define _CCTK_H

#define CCTK_INT   integer
#define CCTK_REAL  real(kind=8)
#define HAVE_SDF_LIB
EOF
$cptr_type = $ENV{'CCTK_C_PTR_TYPE'};

if ($cptr_type eq "") {
  # default case
  print OFILE "#define CCTK_C_PTR integer(kind=4)\n";
}
elsif ($cptr_type eq "integer8") {
  # integer*8
  print OFILE "#define CCTK_C_PTR integer(kind=8)\n";
}
elsif ($cptr_type eq "integer4") {
  # integer*4
  print OFILE "#define CCTK_C_PTR integer(kind=4)\n";
}
else {
  print OFILE "#define CCTK_C_PTR integer(kind=4)\n";
  print STDERR "failed to determine pointer type\n";
}

#
#  hyperMHD has a file that can use quadruple precision (real*16) in F77.  
#  Not all machines support this, so the default will be real*8.  However,
#  if the variable CCTK_F77_QUAD_TYPE is set to real16 at compile time,
#  then real*16 will be used.
#
$quad_type = $ENV{'CCTK_F77_QUAD_TYPE'};
if ($quad_type eq "") {
  # default case
  print OFILE "#define CCTK_F77_QUAD real*8\n";
}
elsif ($cptr_type eq "real16") {
  # real*16
  print OFILE "#define CCTK_F77_QUAD real*16\n";
}
elsif ($cptr_type eq "real8") {
  # real*8
  print OFILE "#define CCTK_F77_QUAD real*8\n";
}
else {
  print OFILE "#define CCTK_F77_QUAD real*8\n";
  print STDERR "failed to determine QUAD type\n";
}


print OFILE "#endif\n";
close(OFILE);

##############################################################################
#
#
#  Write header files for C code.  Necessary for MHD
#
#
##############################################################################
if ($need_c_files) {

$outfile = "cfunc.h";

open(OFILE,">$outfile");

print OFILE<<EOF;

/*------------------------------------------------------------------------
 *
 *  \$Id: hypersetup,v 1.34 2006-07-07 04:11:19 dneilsen Exp $
 *
 *  This is a machine-generated file.  Do not edit this file directly!
 *  (You can, of course, but your changes will be lost...)
 *
 *------------------------------------------------------------------------*/

#ifndef _EQS_FUNC_H
#define _EQS_FUNC_H
EOF

$tnu = $#u + 1;
$tnv = $#v + 1;
$tnw = $#w + 1;


print OFILE "const int NU = $tnu;\n";
print OFILE "const int NV = $tnv;\n";
print OFILE "const int NW = $tnw;\n";

print OFILE "\n";
$indx = 0;
for ($i = 0; $i <= $#u; $i++) {
  $name = $u[$i];
  $name =~ tr/a-z/A-Z/;
  print OFILE "const int UF_$name = $indx;\n";
  $indx++;
}

print OFILE "\n";
$indx = 0;
for ($i = 0; $i <= $#v; $i++) {
  $name = $v[$i];
  $name =~ tr/a-z/A-Z/;
  print OFILE "const int VF_$name = $indx;\n";
  $indx++;
}

print OFILE "\n";
$indx = 0;
for ($i = 0; $i <= $#w; $i++) {
  $name = $w[$i];
  $name =~ tr/a-z/A-Z/;
  print OFILE "const int WF_$name = $indx;\n";
  $indx++;
}


print OFILE "\n";
print OFILE "#endif";
print OFILE "\n";
close(OFILE);

###########################################################################
#
#  Write C parameter file
#
###########################################################################
$outfile = "fpar.h";

open(OFILE,">$outfile");

print OFILE<<EOF;
/*------------------------------------------------------------------------
 *
 *  \$Id: hypersetup,v 1.34 2006-07-07 04:11:19 dneilsen Exp $
 *
 *  This is a machine-generated file.  Do not edit this file directly!
 *  (You can, of course, but your changes will be lost...)
 *
 *------------------------------------------------------------------------*/

#ifndef _FPAR_H
#define _FPAR_H

EOF

$i = 0;
foreach $e (@params) {
  $e1 = $e;
  $e1 =~ s/local_//;
  $e1 =~ tr/a-z/A-Z/;
  print OFILE "#define P_$e1  $i\n";
  $i++;
}


print OFILE "\n";
print OFILE "#endif";
print OFILE "\n";
close(OFILE);

###########################################################################
#
#  Write C parameter file
#
###########################################################################
$outfile = "cpar.h";

open(OFILE,">$outfile");

print OFILE<<EOF;
/*------------------------------------------------------------------------
 *
 *  \$Id: hypersetup,v 1.34 2006-07-07 04:11:19 dneilsen Exp $
 *
 *  This is a machine-generated file.  Do not edit this file directly!
 *  (You can, of course, but your changes will be lost...)
 *
 *------------------------------------------------------------------------*/

#ifndef _CPAR_H
#define _CPAR_H

typedef struct par_t {
EOF

  for ($i=0; $i<=$#params; $i++) {
    $e1 = $params[$i];
    $e1 =~ s/local_//;
    if ($params_type[$i] eq "int") {
      print OFILE "  int $e1;\n";
    }
    if ($params_type[$i] eq "double") {
      print OFILE "  double $e1;\n";
    }
  }

print OFILE<<EOF;
} Par;

#endif
EOF
close(OFILE);

###########################################################################
#
#  Create C parameter structure
#
###########################################################################
$outfile = "cpar.c";

open(OFILE,">$outfile");

print OFILE<<EOF;
/*------------------------------------------------------------------------
 *
 *  \$Id: hypersetup,v 1.34 2006-07-07 04:11:19 dneilsen Exp $
 *
 *  This is a machine-generated file.  Do not edit this file directly!
 *  (You can, of course, but your changes will be lost...)
 *
 *------------------------------------------------------------------------*/
#include "cpar.h"
#include "fpar.h"
void map_pars_(Par **parptr, double *fpar)
{
  static Par par;

EOF
  for ($i=0; $i<=$#params; $i++) {
    $e1 = $params[$i];
    $e1 =~ s/local_//;
    $e2 = $e1;
    $e2 =~ tr/a-z/A-Z/;
    if ($params_type[$i] eq "int") {
      print OFILE "  par.$e1 = (int) fpar[P_$e2];\n";
    }
    if ($params_type[$i] eq "double") {
      print OFILE "  par.$e1 = fpar[P_$e2];\n";
    }
  }


print OFILE<<EOF;

  *parptr = &par;
}
EOF

close(OFILE);

#end NEED_C_FILES
}  
