--------------------------------
03/01/06:
--------------------------------

Here's a description of the clusterer.

The clustering process is required on any given level and proceeds as follows:

----
---- Process the refinement error:
----
1) A rectangular bounding box is found which encompasses all domains of
   all grids that comprise the level (on all processors).
2) Two arrays are allocated to store the error and a flag for each point in
   this bounding box.
3) Because any refined regions must be strictly contained within the current
   level, we can only refine in certain regions of this bounding
   box...keep in mind that when refining levels other than the coarse, we
   will generically not fill this bounding box. To that end, we initialize
   the error to a negative value.
4) For each grid in the level, we take its computed error and mask off
   certain regions (such as its ghostregion). We then copy the remaining
   error values into the error array for the level. Where we do so the
   error is no longer negative indicating that we may refine there.
----
---- Create the flag array:
----
5) At this point, our error array remains negative where we cannot refine
   and is zero or greater where we can refine. Now, we make our flag array
   such that for each point in the bounding box, where the error is negative,
   we flag the point as disallowed, where the error exceeds some user defined
   threshold ("ethreshold"), we flag the point as needing refinement, and
   for all others we flag as not needing refinement.
6) Since we are refining some given level l, we need to ensure that the grids
   we produce on level l+1 contain the existing grids on level l+2. To do so,
   we flag all points in the flag array which fall within the regions spanned
   by grids on level l+2.
6) We then examine the flag array and flag additional points which fall within
   a certain number of points which already are flagged for refinement. This
   is the user chosen value of "buffer" which allows AMR refinement to track
   moving features without re-refining every grid step.
----
---- Group the flagged points into a set of clusters:
----
7) At this point the clusterer is called which produces some "numbox" number
   of clusters:
    a) Initialize a single "box" to the size of the flag array.
    b) Shrink this box from its initial size until it cannot be 
       shrunk anymore without excluding any flagged points.
    c) Compute the efficiency of this box, whether it has any disallowed
       points, and the signatures/laplacians/inflection points (see B&R paper).
    d) If the box's efficiency is too low or if it contains disallowed points,
       then we try to cut the box:
           ^ if:    there are zeros in the signatures, cut there
             else:  try to cut at an inflection point if there is one
           ^ Under some conditions, we back the cut out, and try and a
             different cut on a different axis
           ^ If:   cut is successful, go back to (b) above and continue
             Else: move on to next box, and go back to (b)
    e) At this point, all boxes/clusters should be free of disallowed points,
       and be as efficient as requested by the user (only if cuts were possible/
       successful). We now loop over the boxes and add the ghostwidth region.
----
---- Domain decompose these clusters:
----
8) At this point the clusters are split into pieces appropriate for the
   number of processors on which the code is run.
----
---- End: after this, had creates the appropriate grids, initializes, etc
----
